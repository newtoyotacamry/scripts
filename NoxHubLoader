
-- ─────────────────────────────────────────────────────────────────────────────
-- ▶︎ CONFIGURATION (globals you set before loading)
-- ─────────────────────────────────────────────────────────────────────────────
if type(userKey) ~= "string" or userKey == "" then
    error("❌ No userKey defined. Set `userKey = \"...\"` before loading the script.")
end

-- coerce `auto` into a boolean: accept true/false or "true"/"false"
local autoFlag = (auto == true) or (auto == "true")

-- ─────────────────────────────────────────────────────────────────────────────
-- ▶︎ SERVICES & ENDPOINTS
-- ─────────────────────────────────────────────────────────────────────────────
local HttpService = game:GetService("HttpService")
local Analytics   = game:GetService("RbxAnalyticsService")

local BASE_URL      = "https://roblox-licensing-1.onrender.com"
local CHALLENGE_URL = BASE_URL .. "/loader/challenge"
local VALIDATE_URL  = BASE_URL .. "/loader/validate"

-- sanity check
assert(type(CHALLENGE_URL) == "string", "CHALLENGE_URL is nil")
assert(type(VALIDATE_URL)  == "string", "VALIDATE_URL is nil")

-- ─────────────────────────────────────────────────────────────────────────────
-- ▶︎ HTTP REQUEST ALIAS
-- ─────────────────────────────────────────────────────────────────────────────
local http_request = (syn and syn.request)
                  or (http and http.request)
                  or request
                  or http_request

if not http_request then
    error("❌ No supported HTTP request function found; your exploit may not allow HTTP")
end

-- ─────────────────────────────────────────────────────────────────────────────
-- ▶︎ HELPERS
-- ─────────────────────────────────────────────────────────────────────────────
local function simpleHMAC(input, key)
    return HttpService:UrlEncode(input .. key)
end

local function fetch(url, method, body)
    local ok, res = pcall(http_request, {
        Url     = url,
        Method  = method,
        Headers = { ["Content-Type"] = "application/json" },
        Body    = body or ""
    })
    if not ok then
        error(("❌ HTTP %s %s failed: %s"):format(method, url, tostring(res)))
    end
    return (res.Body or res)
end

local function safeDecode(raw)
    local ok, dec = pcall(HttpService.JSONDecode, HttpService, raw)
    return ok and dec or nil, ok and nil or dec
end

-- ─────────────────────────────────────────────────────────────────────────────
-- ▶︎ GATHER METADATA
-- ─────────────────────────────────────────────────────────────────────────────
local hwid   = tostring(Analytics:GetClientId())
local gameId = tostring(game.GameId)

-- ─────────────────────────────────────────────────────────────────────────────
-- ▶︎ 1) CHALLENGE STEP
-- ─────────────────────────────────────────────────────────────────────────────
local challRaw = fetch(CHALLENGE_URL, "POST", "")
local chall, challErr = safeDecode(challRaw)
if not chall or type(chall.nonce) ~= "string" then
    error("❌ Invalid challenge response: "..tostring(challErr))
end

-- ─────────────────────────────────────────────────────────────────────────────
-- ▶︎ 2) SIGN & VALIDATE
-- ─────────────────────────────────────────────────────────────────────────────
local ts        = tostring(os.time())
local tokenData = chall.nonce .. ":" .. ts .. ":" .. userKey
local clientSig = simpleHMAC(tokenData, SECRET_KEY)

local payload = {
    key       = userKey,
    hwid      = hwid,
    gameId    = gameId,
    nonce     = chall.nonce,
    timestamp = ts,
    sig       = clientSig,
    auto      = autoFlag,
}

local validateRaw, validateErr = fetch(VALIDATE_URL, "POST", HttpService:JSONEncode(payload)), nil
local resp,   respErr     = safeDecode(validateRaw)
if not resp then
    error("❌ Invalid validate response: "..tostring(respErr))
end
if type(resp.code) ~= "string" then
    error("❌ No script code returned.")
end
if type(resp.session) ~= "string" then
    error("❌ No session returned.")
end

-- ─────────────────────────────────────────────────────────────────────────────
-- ▶︎ 3) LAUNCH
-- ─────────────────────────────────────────────────────────────────────────────
_G._session = {
    token = resp.session,
    key   = userKey,
    hwid  = hwid,
}

local fn, loadErr = loadstring(resp.code)
if not fn then
    error("❌ loadstring failed: "..tostring(loadErr))
end
fn()
